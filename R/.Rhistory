Distribution = c("Gumbel (MLE)", "Gumbel (Manual)", "Log-Normal", "Log-Normal (MLE)", "Log-Pearson III"),
NSE = c(nse_gumbel, nse_gumbel_manual, nse_lognormal, nse_lognormal_mle, nse_lp3)
)
# Sort by NSE (descending)
nse_summary <- nse_summary[order(nse_summary$NSE, decreasing = TRUE),]
print("\nNash-Sutcliffe Efficiency (NSE) Summary:")
print(nse_summary)
# =====================================================================
# 7. Probability Plot Correlation Coefficient (PPCC)
# =====================================================================
# Function to calculate PPCC
calculate_ppcc <- function(observed, theoretical) {
cor(observed, theoretical)^2
}
# Calculate PPCC for each distribution
ppcc_gumbel <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_Gumbel_mle))
ppcc_lognormal <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LogNormal))
ppcc_lp3 <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LP3))
# Create a summary data frame for PPCC
ppcc_summary <- data.frame(
Distribution = c("Gumbel", "Log-Normal", "Log-Pearson III"),
PPCC = c(ppcc_gumbel, ppcc_lognormal, ppcc_lp3)
)
# Sort by PPCC (descending)
ppcc_summary <- ppcc_summary[order(ppcc_summary$PPCC, decreasing = TRUE),]
print("\nProbability Plot Correlation Coefficient (PPCC) Summary:")
print(ppcc_summary)
# =====================================================================
# 8. Create QQ Plots for Visual Assessment
# =====================================================================
# Function to create QQ plot data
create_qq_data <- function(observed, theoretical) {
data.frame(
Observed = sort(observed),
Theoretical = sort(theoretical)
)
}
# Create QQ plot data for each distribution
qq_gumbel <- create_qq_data(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
qq_lognormal <- create_qq_data(ams_data$ams, ams_data$Q_pred_LogNormal)
qq_lp3 <- create_qq_data(ams_data$ams, ams_data$Q_pred_LP3)
# Create QQ plots
plot_qq_gumbel <- ggplot(qq_gumbel, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Gumbel Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lognormal <- ggplot(qq_lognormal, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Normal Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lp3 <- ggplot(qq_lp3, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Pearson Type III Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
# Save plots
ggsave("qq_plot_gumbel.png", plot_qq_gumbel, width = 8, height = 6)
ggsave("qq_plot_lognormal.png", plot_qq_lognormal, width = 8, height = 6)
ggsave("qq_plot_lp3.png", plot_qq_lp3, width = 8, height = 6)
# =====================================================================
# 9. Create PP (Probability-Probability) Plots
# =====================================================================
# Function to create PP plot data
create_pp_data <- function(empirical_probs, theoretical_probs) {
data.frame(
Empirical = sort(empirical_probs),
Theoretical = sort(theoretical_probs)
)
}
# Create PP plot data for each distribution
pp_gumbel <- create_pp_data(empirical_probs, theoretical_gumbel)
library(readxl)
library(lubridate)
library(dplyr)
library(extRemes)
library(ggplot2)
library(lmomco)
library(fitdistrplus)
# This script assumes loaddata.R, gumbel.R, lognormal.R, and logpearson.R have been run
# and the necessary objects (ams_data, results, etc.) are available in the environment
# =====================================================================
# 1. Root Mean Square Error (RMSE)
# =====================================================================
# Function to calculate RMSE
calculate_rmse <- function(observed, predicted) {
sqrt(mean((observed - predicted)^2))
}
# Calculate RMSE for each distribution
rmse_gumbel <- calculate_rmse(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
rmse_gumbel_manual <- calculate_rmse(ams_data$ams, ams_data$Q_pred_Gumbel_manual)
rmse_lognormal <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LogNormal)
rmse_lognormal_mle <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LogNormal_MLE)
rmse_lp3 <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LP3)
# Create a summary data frame for RMSE
rmse_summary <- data.frame(
Distribution = c("Gumbel (MLE)", "Gumbel (Manual)", "Log-Normal", "Log-Normal (MLE)", "Log-Pearson III"),
RMSE = c(rmse_gumbel, rmse_gumbel_manual, rmse_lognormal, rmse_lognormal_mle, rmse_lp3)
)
# Sort by RMSE (ascending)
rmse_summary <- rmse_summary[order(rmse_summary$RMSE),]
print("Root Mean Square Error (RMSE) Summary:")
print(rmse_summary)
# =====================================================================
# 2. Nash-Sutcliffe Efficiency (NSE)
# =====================================================================
# Function to calculate NSE
calculate_nse <- function(observed, predicted) {
1 - sum((observed - predicted)^2) / sum((observed - mean(observed))^2)
}
# Calculate NSE for each distribution
nse_gumbel <- calculate_nse(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
nse_gumbel_manual <- calculate_nse(ams_data$ams, ams_data$Q_pred_Gumbel_manual)
nse_lognormal <- calculate_nse(ams_data$ams, ams_data$Q_pred_LogNormal)
nse_lognormal_mle <- calculate_nse(ams_data$ams, ams_data$Q_pred_LogNormal_MLE)
nse_lp3 <- calculate_nse(ams_data$ams, ams_data$Q_pred_LP3)
# Create a summary data frame for NSE
nse_summary <- data.frame(
Distribution = c("Gumbel (MLE)", "Gumbel (Manual)", "Log-Normal", "Log-Normal (MLE)", "Log-Pearson III"),
NSE = c(nse_gumbel, nse_gumbel_manual, nse_lognormal, nse_lognormal_mle, nse_lp3)
)
# Sort by NSE (descending)
nse_summary <- nse_summary[order(nse_summary$NSE, decreasing = TRUE),]
print("\nNash-Sutcliffe Efficiency (NSE) Summary:")
print(nse_summary)
# =====================================================================
# 7. Probability Plot Correlation Coefficient (PPCC)
# =====================================================================
# Function to calculate PPCC
calculate_ppcc <- function(observed, theoretical) {
cor(observed, theoretical)^2
}
# Calculate PPCC for each distribution
ppcc_gumbel <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_Gumbel_mle))
ppcc_lognormal <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LogNormal))
ppcc_lp3 <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LP3))
# Create a summary data frame for PPCC
ppcc_summary <- data.frame(
Distribution = c("Gumbel", "Log-Normal", "Log-Pearson III"),
PPCC = c(ppcc_gumbel, ppcc_lognormal, ppcc_lp3)
)
# Sort by PPCC (descending)
ppcc_summary <- ppcc_summary[order(ppcc_summary$PPCC, decreasing = TRUE),]
print("\nProbability Plot Correlation Coefficient (PPCC) Summary:")
print(ppcc_summary)
# =====================================================================
# 8. Create QQ Plots for Visual Assessment
# =====================================================================
# Function to create QQ plot data
create_qq_data <- function(observed, theoretical) {
data.frame(
Observed = sort(observed),
Theoretical = sort(theoretical)
)
}
# Create QQ plot data for each distribution
qq_gumbel <- create_qq_data(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
qq_lognormal <- create_qq_data(ams_data$ams, ams_data$Q_pred_LogNormal)
qq_lp3 <- create_qq_data(ams_data$ams, ams_data$Q_pred_LP3)
# Create QQ plots
plot_qq_gumbel <- ggplot(qq_gumbel, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Gumbel Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lognormal <- ggplot(qq_lognormal, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Normal Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lp3 <- ggplot(qq_lp3, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Pearson Type III Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
# Save plots
ggsave("qq_plot_gumbel.png", plot_qq_gumbel, width = 8, height = 6)
ggsave("qq_plot_lognormal.png", plot_qq_lognormal, width = 8, height = 6)
ggsave("qq_plot_lp3.png", plot_qq_lp3, width = 8, height = 6)
# =====================================================================
# 10. Confidence Intervals for Return Levels
# =====================================================================
# Using analytical approximations for standard errors
# For Gumbel distribution
calculate_gumbel_ci <- function(return_period, mean_q, sd_q, n, conf_level = 0.95) {
# Get the reduced variate for the return period
y_t <- -log(-log(1 - 1/return_period))
# Calculate the standard error of the quantile estimate
# Using the approximate formula from Rao and Hamed (2000)
se_factor <- sqrt(1/n * (1.1087 + 0.5140 * y_t + 0.6079 * y_t^2))
se <- sd_q * se_factor
# Calculate the confidence interval
z <- qnorm((1 + conf_level) / 2)
q_t <- mean_q + sd_q * (y_t - 0.5772) / 1.2825  # Gumbel quantile
lower_ci <- q_t - z * se
upper_ci <- q_t + z * se
return(c(lower_ci, q_t, upper_ci))
}
# For LogNormal distribution
calculate_lognormal_ci <- function(return_period, meanlog, sdlog, n, conf_level = 0.95) {
# Get the standard normal quantile for the return period
z_p <- qnorm(1 - 1/return_period)
# Calculate the standard error of the quantile estimate
# Using the delta method
se_factor <- sqrt(1/n * (1 + 0.5 * z_p^2))
se <- sdlog * se_factor
# Calculate the confidence interval
z <- qnorm((1 + conf_level) / 2)
q_t <- exp(meanlog + z_p * sdlog)  # LogNormal quantile
lower_ci <- exp(meanlog + z_p * sdlog - z * se)
upper_ci <- exp(meanlog + z_p * sdlog + z * se)
return(c(lower_ci, q_t, upper_ci))
}
# Calculate confidence intervals for each distribution and return period
ci_results <- data.frame(
ReturnPeriod = results$T,
Gumbel_Lower = NA,
Gumbel_Q = NA,
Gumbel_Upper = NA,
LogNormal_Lower = NA,
LogNormal_Q = NA,
LogNormal_Upper = NA
)
# Sample size
n <- nrow(ams_data)
# Calculate CIs for each return period
for (i in 1:nrow(ci_results)) {
t <- ci_results$ReturnPeriod[i]
# Gumbel CIs
gumbel_ci <- calculate_gumbel_ci(t, mean(ams_data$ams), sd(ams_data$ams), n)
ci_results$Gumbel_Lower[i] <- gumbel_ci[1]
ci_results$Gumbel_Q[i] <- gumbel_ci[2]
ci_results$Gumbel_Upper[i] <- gumbel_ci[3]
# LogNormal CIs
lognormal_ci <- calculate_lognormal_ci(t, lognormal_fit$estimate["meanlog"],
lognormal_fit$estimate["sdlog"], n)
ci_results$LogNormal_Lower[i] <- lognormal_ci[1]
ci_results$LogNormal_Q[i] <- lognormal_ci[2]
ci_results$LogNormal_Upper[i] <- lognormal_ci[3]
}
print("\nConfidence Intervals for Return Levels:")
print(ci_results)
# =====================================================================
# 11. Summary of All Goodness of Fit Metrics
# =====================================================================
# Create a comprehensive summary table
gof_summary <- data.frame(
Distribution = c("Gumbel", "Log-Normal", "Log-Pearson III"),
RMSE = c(rmse_gumbel, rmse_lognormal, rmse_lp3),
NSE = c(nse_gumbel, nse_lognormal, nse_lp3),
PPCC = c(ppcc_gumbel, ppcc_lognormal, ppcc_lp3),
KS_Stat = c(ks_gumbel$statistic, ks_lognormal$statistic, ks_lp3_statistic),
KS_PValue = c(ks_gumbel$p.value, ks_lognormal$p.value, ks_lp3_pvalue)
)
library(readxl)
library(lubridate)
library(dplyr)
library(extRemes)
library(ggplot2)
library(lmomco)
library(fitdistrplus)
# This script assumes loaddata.R, gumbel.R, lognormal.R, and logpearson.R have been run
# and the necessary objects (ams_data, results, etc.) are available in the environment
# =====================================================================
# 1. Root Mean Square Error (RMSE)
# =====================================================================
# Function to calculate RMSE
calculate_rmse <- function(observed, predicted) {
sqrt(mean((observed - predicted)^2))
}
# Calculate RMSE for each distribution
rmse_gumbel <- calculate_rmse(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
rmse_gumbel_manual <- calculate_rmse(ams_data$ams, ams_data$Q_pred_Gumbel_manual)
rmse_lognormal <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LogNormal)
rmse_lognormal_mle <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LogNormal_MLE)
rmse_lp3 <- calculate_rmse(ams_data$ams, ams_data$Q_pred_LP3)
# Create a summary data frame for RMSE
rmse_summary <- data.frame(
Distribution = c("Gumbel (MLE)", "Gumbel (Manual)", "Log-Normal", "Log-Normal (MLE)", "Log-Pearson III"),
RMSE = c(rmse_gumbel, rmse_gumbel_manual, rmse_lognormal, rmse_lognormal_mle, rmse_lp3)
)
# Sort by RMSE (ascending)
rmse_summary <- rmse_summary[order(rmse_summary$RMSE),]
print("Root Mean Square Error (RMSE) Summary:")
print(rmse_summary)
# =====================================================================
# 2. Nash-Sutcliffe Efficiency (NSE)
# =====================================================================
# Function to calculate NSE
calculate_nse <- function(observed, predicted) {
1 - sum((observed - predicted)^2) / sum((observed - mean(observed))^2)
}
# Calculate NSE for each distribution
nse_gumbel <- calculate_nse(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
nse_gumbel_manual <- calculate_nse(ams_data$ams, ams_data$Q_pred_Gumbel_manual)
nse_lognormal <- calculate_nse(ams_data$ams, ams_data$Q_pred_LogNormal)
nse_lognormal_mle <- calculate_nse(ams_data$ams, ams_data$Q_pred_LogNormal_MLE)
nse_lp3 <- calculate_nse(ams_data$ams, ams_data$Q_pred_LP3)
# Create a summary data frame for NSE
nse_summary <- data.frame(
Distribution = c("Gumbel (MLE)", "Gumbel (Manual)", "Log-Normal", "Log-Normal (MLE)", "Log-Pearson III"),
NSE = c(nse_gumbel, nse_gumbel_manual, nse_lognormal, nse_lognormal_mle, nse_lp3)
)
# Sort by NSE (descending)
nse_summary <- nse_summary[order(nse_summary$NSE, decreasing = TRUE),]
print("\nNash-Sutcliffe Efficiency (NSE) Summary:")
print(nse_summary)
# =====================================================================
# 7. Probability Plot Correlation Coefficient (PPCC)
# =====================================================================
# Function to calculate PPCC
calculate_ppcc <- function(observed, theoretical) {
cor(observed, theoretical)^2
}
# Calculate PPCC for each distribution
ppcc_gumbel <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_Gumbel_mle))
ppcc_lognormal <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LogNormal))
ppcc_lp3 <- calculate_ppcc(sort(ams_data$ams), sort(ams_data$Q_pred_LP3))
# Create a summary data frame for PPCC
ppcc_summary <- data.frame(
Distribution = c("Gumbel", "Log-Normal", "Log-Pearson III"),
PPCC = c(ppcc_gumbel, ppcc_lognormal, ppcc_lp3)
)
# Sort by PPCC (descending)
ppcc_summary <- ppcc_summary[order(ppcc_summary$PPCC, decreasing = TRUE),]
print("\nProbability Plot Correlation Coefficient (PPCC) Summary:")
print(ppcc_summary)
# =====================================================================
# 8. Create QQ Plots for Visual Assessment
# =====================================================================
# Function to create QQ plot data
create_qq_data <- function(observed, theoretical) {
data.frame(
Observed = sort(observed),
Theoretical = sort(theoretical)
)
}
# Create QQ plot data for each distribution
qq_gumbel <- create_qq_data(ams_data$ams, ams_data$Q_pred_Gumbel_mle)
qq_lognormal <- create_qq_data(ams_data$ams, ams_data$Q_pred_LogNormal)
qq_lp3 <- create_qq_data(ams_data$ams, ams_data$Q_pred_LP3)
# Create QQ plots
plot_qq_gumbel <- ggplot(qq_gumbel, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Gumbel Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lognormal <- ggplot(qq_lognormal, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Normal Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
plot_qq_lp3 <- ggplot(qq_lp3, aes(x = Theoretical, y = Observed)) +
geom_point() +
geom_abline(intercept = 0, slope = 1, color = "red", linetype = "dashed") +
labs(title = "QQ Plot - Log-Pearson Type III Distribution",
x = "Theoretical Quantiles",
y = "Observed Quantiles") +
theme_minimal()
# Save plots
ggsave("qq_plot_gumbel.png", plot_qq_gumbel, width = 8, height = 6)
ggsave("qq_plot_lognormal.png", plot_qq_lognormal, width = 8, height = 6)
ggsave("qq_plot_lp3.png", plot_qq_lp3, width = 8, height = 6)
# =====================================================================
# 10. Confidence Intervals for Return Levels
# =====================================================================
# Using analytical approximations for standard errors
# For Gumbel distribution
calculate_gumbel_ci <- function(return_period, mean_q, sd_q, n, conf_level = 0.95) {
# Get the reduced variate for the return period
y_t <- -log(-log(1 - 1/return_period))
# Calculate the standard error of the quantile estimate
# Using the approximate formula from Rao and Hamed (2000)
se_factor <- sqrt(1/n * (1.1087 + 0.5140 * y_t + 0.6079 * y_t^2))
se <- sd_q * se_factor
# Calculate the confidence interval
z <- qnorm((1 + conf_level) / 2)
q_t <- mean_q + sd_q * (y_t - 0.5772) / 1.2825  # Gumbel quantile
lower_ci <- q_t - z * se
upper_ci <- q_t + z * se
return(c(lower_ci, q_t, upper_ci))
}
# For LogNormal distribution
calculate_lognormal_ci <- function(return_period, meanlog, sdlog, n, conf_level = 0.95) {
# Get the standard normal quantile for the return period
z_p <- qnorm(1 - 1/return_period)
# Calculate the standard error of the quantile estimate
# Using the delta method
se_factor <- sqrt(1/n * (1 + 0.5 * z_p^2))
se <- sdlog * se_factor
# Calculate the confidence interval
z <- qnorm((1 + conf_level) / 2)
q_t <- exp(meanlog + z_p * sdlog)  # LogNormal quantile
lower_ci <- exp(meanlog + z_p * sdlog - z * se)
upper_ci <- exp(meanlog + z_p * sdlog + z * se)
return(c(lower_ci, q_t, upper_ci))
}
# Calculate confidence intervals for each distribution and return period
ci_results <- data.frame(
ReturnPeriod = results$T,
Gumbel_Lower = NA,
Gumbel_Q = NA,
Gumbel_Upper = NA,
LogNormal_Lower = NA,
LogNormal_Q = NA,
LogNormal_Upper = NA
)
# Sample size
n <- nrow(ams_data)
# Calculate CIs for each return period
for (i in 1:nrow(ci_results)) {
t <- ci_results$ReturnPeriod[i]
# Gumbel CIs
gumbel_ci <- calculate_gumbel_ci(t, mean(ams_data$ams), sd(ams_data$ams), n)
ci_results$Gumbel_Lower[i] <- gumbel_ci[1]
ci_results$Gumbel_Q[i] <- gumbel_ci[2]
ci_results$Gumbel_Upper[i] <- gumbel_ci[3]
# LogNormal CIs
lognormal_ci <- calculate_lognormal_ci(t, lognormal_fit$estimate["meanlog"],
lognormal_fit$estimate["sdlog"], n)
ci_results$LogNormal_Lower[i] <- lognormal_ci[1]
ci_results$LogNormal_Q[i] <- lognormal_ci[2]
ci_results$LogNormal_Upper[i] <- lognormal_ci[3]
}
print("\nConfidence Intervals for Return Levels:")
print(ci_results)
# =====================================================================
# 11. Summary of All Goodness of Fit Metrics
# =====================================================================
# Create a comprehensive summary table
gof_summary <- data.frame(
Distribution = c("Gumbel", "Log-Normal", "Log-Pearson III"),
RMSE = c(rmse_gumbel, rmse_lognormal, rmse_lp3),
NSE = c(nse_gumbel, nse_lognormal, nse_lp3),
PPCC = c(ppcc_gumbel, ppcc_lognormal, ppcc_lp3)
)
# Add ranking columns
gof_summary$RMSE_Rank <- rank(gof_summary$RMSE)
gof_summary$NSE_Rank <- rank(-gof_summary$NSE)  # Negative because higher NSE is better
gof_summary$PPCC_Rank <- rank(-gof_summary$PPCC)  # Negative because higher PPCC is better
# Calculate overall rank
gof_summary$Overall_Rank <- rowMeans(gof_summary[, c("RMSE_Rank", "NSE_Rank", "PPCC_Rank")])
# Sort by overall rank
gof_summary <- gof_summary[order(gof_summary$Overall_Rank),]
print("\nComprehensive Goodness of Fit Summary:")
print(gof_summary)
# Final conclusion on best-fitting distribution
best_dist <- gof_summary$Distribution[1]
cat("\nBased on the goodness of fit metrics, the", best_dist, "distribution provides the best fit to the data.\n")
# =====================================================================
# 12. Create Return Period Plots with Confidence Intervals
# =====================================================================
# Create a data frame for plotting
plot_data <- data.frame(
ReturnPeriod = rep(results$T, 3),
Discharge = c(results$Gumbel_Q_Pred, results$LogNormal_Q_Pred, results$LP3_Q_Pred),
Distribution = rep(c("Gumbel", "Log-Normal", "Log-Pearson III"), each = length(results$T))
)
# Add observed data points
observed_data <- data.frame(
ReturnPeriod = ams_data$ReturnPeriod,
Discharge = ams_data$ams,
Distribution = "Observed"
)
# Create the return period plot
return_period_plot <- ggplot() +
geom_line(data = plot_data, aes(x = ReturnPeriod, y = Discharge, color = Distribution)) +
geom_point(data = observed_data, aes(x = ReturnPeriod, y = Discharge), color = "black") +
# Add Gumbel confidence intervals
geom_ribbon(data = ci_results, aes(x = ReturnPeriod,
ymin = Gumbel_Lower,
ymax = Gumbel_Upper),
fill = "blue", alpha = 0.2) +
# Add LogNormal confidence intervals
geom_ribbon(data = ci_results, aes(x = ReturnPeriod,
ymin = LogNormal_Lower,
ymax = LogNormal_Upper),
fill = "red", alpha = 0.2) +
scale_x_log10() +
annotation_logticks(sides = "b") +
labs(title = "Flood Frequency Curves with Confidence Intervals",
x = "Return Period (years)",
y = "Discharge (cusecs)",
color = "Distribution") +
theme_minimal()
# Save the plot
ggsave("return_period_plot.png", return_period_plot, width = 10, height = 6)
# Print a summary of what has been done
cat("\nAnalysis Complete! The following outputs have been generated:\n")
cat("1. Goodness of fit statistics (RMSE, NSE, KS, Chi-Square, PPCC)\n")
cat("2. QQ and PP plots for visual assessment\n")
cat("3. Confidence intervals for return levels\n")
cat("4. Return period plot with confidence intervals\n")
cat("5. Overall ranking of distributions\n")
cat("\nThe best-fitting distribution is:", best_dist, "\n")
